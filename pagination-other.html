<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-07-15T14:54:13.011364209"><title>Other types of pagination | apollo-kotlin-normalized-cache</title><script type="application/json" id="virtual-toc-data">[{"id":"pagination-arguments","level":0,"title":"Pagination arguments","anchor":"#pagination-arguments"},{"id":"record-merging","level":0,"title":"Record merging","anchor":"#record-merging"},{"id":"metadata","level":0,"title":"Metadata","anchor":"#metadata"},{"id":"embedded-fields","level":0,"title":"Embedded fields","anchor":"#embedded-fields"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b575/app.css" rel="stylesheet"><link href="static/custom.css" rel="stylesheet"><link rel="icon" type="image/png" sizes="16x16" href="images/favicon-96x96.png"><link rel="icon" type="image/png" sizes="32x32" href="images/favicon-192x192.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Other types of pagination | apollo-kotlin-normalized-cache"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="apollo-kotlin-normalized-cache Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/pagination-other.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Other types of pagination | apollo-kotlin-normalized-cache"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/pagination-other.html#webpage",
    "url": "writerside-documentation/pagination-other.html",
    "name": "Other types of pagination | apollo-kotlin-normalized-cache",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "apollo-kotlin-normalized-cache Help"
}</script><!-- End Schema.org --></head><body data-id="pagination-other" data-main-title="Other types of pagination" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="pagination-home.md|Pagination" data-edit-url="https://github.com/apollographql/apollo-kotlin-normalized-cache/edit/main/Writerside/topics/pagination/pagination-other.md"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>apollo-kotlin-normalized-cache  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="pagination-other" id="pagination-other.md">Other types of pagination</h1><p id="f1l0lx_3">If your schema doesn't use <a href="https://relay.dev/graphql/connections.htm" id="f1l0lx_8" data-external="true" rel="noopener noreferrer">Relay-style</a> pagination, you can still use the pagination support, with more configuration needed.</p><section class="chapter"><h2 id="pagination-arguments" data-toc="pagination-arguments">Pagination arguments</h2><p id="f1l0lx_9">The <code class="code" id="f1l0lx_20">@fieldPolicy</code> directive has a <code class="code" id="f1l0lx_21">paginationArgs</code> argument that can be used to specify the arguments that should be omitted from the field key.</p><p id="f1l0lx_10">Going back to <a href="pagination-home.html" id="f1l0lx_22" data-tooltip="The normalized cache includes support for pagination, allowing you to merge pages of data into the same record field. This allows your application to watch a query for a list of items, receive updates when new pages are fetched, and update the UI with the full list.">the example</a> with <code class="code" id="f1l0lx_23">usersPage</code>:</p><div class="code-block" data-lang="graphql">
extend type Query
@fieldPolicy(forField: &quot;usersPage&quot; paginationArgs: &quot;page&quot;)
</div><aside class="prompt" data-type="tip" data-title="" id="f1l0lx_12"><p id="f1l0lx_24">This can also be done programmatically by configuring your cache with a <a href="https://apollographql.github.io/apollo-kotlin-normalized-cache/kdoc/normalized-cache/com.apollographql.cache.normalized.api/-field-key-generator/index.html?query=interface%20FieldKeyGenerator" id="f1l0lx_25" data-external="true" rel="noopener noreferrer"><code class="code" id="f1l0lx_26">FieldKeyGenerator</code></a> implementation.</p></aside><p id="f1l0lx_13">With that in place, after fetching the first page, the cache will look like this:</p><div class="table-wrapper"><table class="wide" id="f1l0lx_14"><thead><tr class="ijRowHead" id="f1l0lx_27"><th id="f1l0lx_31"><p>Cache Key</p></th><th id="f1l0lx_32"><p>Record</p></th></tr></thead><tbody><tr id="f1l0lx_28"><td id="f1l0lx_33"><p>QUERY_ROOT</p></td><td id="f1l0lx_34"><p><span class="control" id="f1l0lx_35">usersPage(groupId: 2)</span>: [ref(user:1), ref(user:2)]</p></td></tr><tr id="f1l0lx_29"><td id="f1l0lx_36"><p>user:1</p></td><td id="f1l0lx_37"><p>id: 1, name: John Smith</p></td></tr><tr id="f1l0lx_30"><td id="f1l0lx_38"><p>user:2</p></td><td id="f1l0lx_39"><p>id: 2, name: Jane Doe</p></td></tr></tbody></table></div><p id="f1l0lx_15">The field key no longer includes the <code class="code" id="f1l0lx_40">page</code> argument, which means watching <code class="code" id="f1l0lx_41">UsersPage(page = 1)</code> or any page will observe the same list.</p><p id="f1l0lx_16">Here's what happens when fetching the second page:</p><div class="table-wrapper"><table class="wide" id="f1l0lx_17"><thead><tr class="ijRowHead" id="f1l0lx_42"><th id="f1l0lx_48"><p>Cache Key</p></th><th id="f1l0lx_49"><p>Record</p></th></tr></thead><tbody><tr id="f1l0lx_43"><td id="f1l0lx_50"><p>QUERY_ROOT</p></td><td id="f1l0lx_51"><p>usersPage(groupId: 2): [ref(user:3), ref(user:4)]</p></td></tr><tr id="f1l0lx_44"><td id="f1l0lx_52"><p>user:1</p></td><td id="f1l0lx_53"><p>id: 1, name: John Smith</p></td></tr><tr id="f1l0lx_45"><td id="f1l0lx_54"><p>user:2</p></td><td id="f1l0lx_55"><p>id: 2, name: Jane Doe</p></td></tr><tr id="f1l0lx_46"><td id="f1l0lx_56"><p>user:3</p></td><td id="f1l0lx_57"><p>id: 3, name: Peter Parker</p></td></tr><tr id="f1l0lx_47"><td id="f1l0lx_58"><p>user:4</p></td><td id="f1l0lx_59"><p>id: 4, name: Bruce Wayne</p></td></tr></tbody></table></div><p id="f1l0lx_18">The field containing the first page was overwritten by the second page.</p><p id="f1l0lx_19">This is because the field key is now the same for all pages and the default merging strategy is to overwrite existing fields with the new value.</p></section><section class="chapter"><h2 id="record-merging" data-toc="record-merging">Record merging</h2><p id="f1l0lx_60">To fix this, we need to supply the store with a piece of code that can merge the lists in a sensible way. This is done by passing a <a href="https://apollographql.github.io/apollo-kotlin-normalized-cache/kdoc/normalized-cache/com.apollographql.cache.normalized.api/-record-merger/index.html?query=interface%20RecordMerger" id="f1l0lx_67" data-external="true" rel="noopener noreferrer"><code class="code" id="f1l0lx_68">RecordMerger</code></a> when configuring your cache:</p><div class="code-block" data-lang="kotlin">
object MyFieldMerger : FieldRecordMerger.FieldMerger {
  override fun mergeFields(existing: FieldRecordMerger.FieldInfo, incoming: FieldRecordMerger.FieldInfo): FieldRecordMerger.FieldInfo {
    val existingList = existing.value as List&lt;*&gt;
    val incomingList = incoming.value as List&lt;*&gt;
    val mergedList = existingList + incomingList
    return FieldRecordMerger.FieldInfo(
        value = mergedList,
        metadata = emptyMap()
    )
  }
}

val client = ApolloClient.Builder()
  // ...
  .normalizedCache(
    normalizedCacheFactory = cacheFactory,
    recordMerger = FieldRecordMerger(MyFieldMerger), // Configure the store with the custom merger
  )
  .build()
</div><p id="f1l0lx_62">With this, the cache will be as expected after fetching the second page:</p><div class="table-wrapper"><table class="wide" id="f1l0lx_63"><thead><tr class="ijRowHead" id="f1l0lx_69"><th id="f1l0lx_75"><p>Cache Key</p></th><th id="f1l0lx_76"><p>Record</p></th></tr></thead><tbody><tr id="f1l0lx_70"><td id="f1l0lx_77"><p>QUERY_ROOT</p></td><td id="f1l0lx_78"><p>usersPage(groupId: 2): [ref(user:1), ref(user:2), ref(user:3), ref(user:4)]</p></td></tr><tr id="f1l0lx_71"><td id="f1l0lx_79"><p>user:1</p></td><td id="f1l0lx_80"><p>id: 1, name: John Smith</p></td></tr><tr id="f1l0lx_72"><td id="f1l0lx_81"><p>user:2</p></td><td id="f1l0lx_82"><p>id: 2, name: Jane Doe</p></td></tr><tr id="f1l0lx_73"><td id="f1l0lx_83"><p>user:3</p></td><td id="f1l0lx_84"><p>id: 3, name: Peter Parker</p></td></tr><tr id="f1l0lx_74"><td id="f1l0lx_85"><p>user:4</p></td><td id="f1l0lx_86"><p>id: 4, name: Bruce Wayne</p></td></tr></tbody></table></div><p id="f1l0lx_64">The <code class="code" id="f1l0lx_87">RecordMerger</code> shown above is simplistic: it will always append new items to the end of the existing list. In a real app, we need to look at the contents of the incoming page and decide if and where to append / insert the items.</p><p id="f1l0lx_65">To do that it is usually necessary to have access to the arguments that were used to fetch the existing/incoming lists (e.g. the page number), to decide what to do with the new items. For instance if the existing list is for page 1 and the incoming one is for page 2, we should append.</p><p id="f1l0lx_66">Fields in records can have arbitrary metadata attached to them, in addition to their value. We'll use this to implement a more capable merging strategy.</p></section><section class="chapter"><h2 id="metadata" data-toc="metadata">Metadata</h2><p id="f1l0lx_88">Let's go back to the <a href="pagination-relay-style.html" id="f1l0lx_96" data-tooltip="Relay-style pagination is a common way of modeling pagination in GraphQL, where fields return Connections that contain a list of Edges:">example</a> where Relay-style pagination is used.</p><p id="f1l0lx_89">Configure the <code class="code" id="f1l0lx_97">paginationArgs</code> as seen previously:</p><div class="code-block" data-lang="graphql">
extend type Query
@fieldPolicy(forField: &quot;usersConnection&quot; paginationArgs: &quot;first,after,last,before&quot;)
</div><p id="f1l0lx_91">Now let's store in the metadata of each <code class="code" id="f1l0lx_98">UserConnection</code> field the values of the <code class="code" id="f1l0lx_99">before</code> and <code class="code" id="f1l0lx_100">after</code> arguments of the field returning it, as well as the values of the first and last cursor in its list. This will allow us to insert new pages in the correct position later on.</p><p id="f1l0lx_92">This is done by passing a <a href="https://apollographql.github.io/apollo-kotlin-normalized-cache/kdoc/normalized-cache/com.apollographql.cache.normalized.api/-metadata-generator/index.html?query=interface%20MetadataGenerator" id="f1l0lx_101" data-external="true" rel="noopener noreferrer"><code class="code" id="f1l0lx_102">MetadataGenerator</code></a> when configuring the cache:</p><div class="code-block" data-lang="kotlin">
class ConnectionMetadataGenerator : MetadataGenerator {
  @Suppress(&quot;UNCHECKED_CAST&quot;)
  override fun metadataForObject(obj: ApolloJsonElement, context: MetadataGeneratorContext): Map&lt;String, ApolloJsonElement&gt; {
    if (context.field.type.rawType().name == &quot;UserConnection&quot;) {
      obj as Map&lt;String, ApolloJsonElement&gt;
      val edges = obj[&quot;edges&quot;] as List&lt;Map&lt;String, ApolloJsonElement&gt;&gt;
      val startCursor = edges.firstOrNull()?.get(&quot;cursor&quot;) as String?
      val endCursor = edges.lastOrNull()?.get(&quot;cursor&quot;) as String?
      return mapOf(
          &quot;startCursor&quot; to startCursor,
          &quot;endCursor&quot; to endCursor,
          &quot;before&quot; to context.argumentValue(&quot;before&quot;),
          &quot;after&quot; to context.argumentValue(&quot;after&quot;),
      )
    }
    return emptyMap()
  }
}
</div><p id="f1l0lx_94">However, this cannot work yet.</p><p id="f1l0lx_95">Normalization will make the <code class="code" id="f1l0lx_103">usersConnection</code> field value be a <span class="control" id="f1l0lx_104">reference</span> to the <code class="code" id="f1l0lx_105">UserConnection</code> record, and not the actual connection. Because of this, we won't be able to access its metadata inside the <code class="code" id="f1l0lx_106">RecordMerger</code> implementation. Furthermore, the <code class="code" id="f1l0lx_107">edges</code> field value will be a list of <span class="control" id="f1l0lx_108">references</span> to the <code class="code" id="f1l0lx_109">UserEdge</code> records which will contain the item's list index in their cache key (e.g. <code class="code" id="f1l0lx_110">usersConnection.edges.0</code>, <code class="code" id="f1l0lx_111">usersConnection.edges.1</code>) which will break the merging logic.</p></section><section class="chapter"><h2 id="embedded-fields" data-toc="embedded-fields">Embedded fields</h2><p id="f1l0lx_112">To remediate this, we can configure the cache to skip normalization for certain fields. When doing so, the value will be embedded directly into the record instead of being referenced.</p><p id="f1l0lx_113">This is done with the <code class="code" id="f1l0lx_119">embeddedFields</code> argument of the <code class="code" id="f1l0lx_120">@typePolicy</code> directive:</p><div class="code-block" data-lang="graphql">
# Embed the value of the `usersConnection` field in the record
extend type Query @typePolicy(embeddedFields: &quot;usersConnection&quot;)

# Embed the values of the `edges` field in the record
extend type UserConnection @typePolicy(embeddedFields: &quot;edges&quot;)
</div><aside class="prompt" data-type="tip" data-title="" id="f1l0lx_115"><p id="f1l0lx_121">This can also be done programmatically by configuring the cache with an <a href="https://apollographql.github.io/apollo-kotlin-normalized-cache/kdoc/normalized-cache/com.apollographql.cache.normalized.api/-embedded-fields-provider/index.html?query=interface%20EmbeddedFieldsProvider" id="f1l0lx_122" data-external="true" rel="noopener noreferrer"><code class="code" id="f1l0lx_123">EmbeddedFieldsProvider</code></a> implementation.</p></aside><p id="f1l0lx_116">Now that we have the metadata and embedded fields in place, we can implement the <code class="code" id="f1l0lx_124">RecordMerger</code> (simplified for brevity):</p><div class="code-block" data-lang="kotlin">
object ConnectionFieldMerger : FieldRecordMerger.FieldMerger {
  @Suppress(&quot;UNCHECKED_CAST&quot;)
  override fun mergeFields(existing: FieldRecordMerger.FieldInfo, incoming: FieldRecordMerger.FieldInfo): FieldRecordMerger.FieldInfo {
    // Get existing field metadata
    val existingStartCursor = existing.metadata[&quot;startCursor&quot;]
    val existingEndCursor = existing.metadata[&quot;endCursor&quot;]

    // Get incoming field metadata
    val incomingBeforeArgument = incoming.metadata[&quot;before&quot;]
    val incomingAfterArgument = incoming.metadata[&quot;after&quot;]

    // Get the lists
    val existingList = (existing.value as Map&lt;String, ApolloJsonElement&gt;)[&quot;edges&quot;] as List&lt;*&gt;
    val incomingList = (incoming.value as Map&lt;String, ApolloJsonElement&gt;)[&quot;edges&quot;] as List&lt;*&gt;

    // Merge the lists
    val mergedList: List&lt;*&gt; = if (incomingAfterArgument == existingEndCursor) {
      // We received the next page: its `after` argument matches the last cursor of the existing list
      existingList + incomingList
    } else if (incomingBeforeArgument == existingStartCursor) {
      // We received the previous page: its `before` argument matches the first cursor of the existing list
      incomingList + existingList
    } else {
      // We received a list which is neither the previous nor the next page.
      // Handle this case by resetting the cache with this page
      incomingList
    }

    val mergedFieldValue = existing.value.toMutableMap()
    mergedFieldValue[&quot;edges&quot;] = mergedList
    return FieldRecordMerger.FieldInfo(
        value = mergedFieldValue,
        metadata = mapOf() // Omitted for brevity
    )
  }
}
</div><p id="f1l0lx_118">A full implementation of <code class="code" id="f1l0lx_125">ConnectionFieldMerger</code> can be found <a href="https://github.com/apollographql/apollo-kotlin-normalized-cache/blob/main/normalized-cache/src/commonMain/kotlin/com/apollographql/cache/normalized/api/RecordMerger.kt#L136" id="f1l0lx_126" data-external="true" rel="noopener noreferrer">here</a>.</p></section><div class="last-modified">Last modified: 28 April 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="pagination-relay-style.html" class="navigation-links__prev">Relay-style pagination</a><a href="pagination-manual.html" class="navigation-links__next">Managing pagination manually</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b575/app.js"></script></body></html>