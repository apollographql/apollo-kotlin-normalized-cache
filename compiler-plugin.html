<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-07-15T14:54:13.00885432"><title>Compiler plugin | apollo-kotlin-normalized-cache</title><script type="application/json" id="virtual-toc-data">[{"id":"declarative-cache-ids-typepolicy","level":0,"title":"Declarative cache IDs (@typePolicy)","anchor":"#declarative-cache-ids-typepolicy"},{"id":"resolving-to-cache-keys-fieldpolicy","level":0,"title":"Resolving to cache keys (@fieldPolicy)","anchor":"#resolving-to-cache-keys-fieldpolicy"},{"id":"cache-extension-function","level":0,"title":"cache() extension function","anchor":"#cache-extension-function"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b575/app.css" rel="stylesheet"><link href="static/custom.css" rel="stylesheet"><link rel="icon" type="image/png" sizes="16x16" href="images/favicon-96x96.png"><link rel="icon" type="image/png" sizes="32x32" href="images/favicon-192x192.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Compiler plugin | apollo-kotlin-normalized-cache"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="apollo-kotlin-normalized-cache Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/compiler-plugin.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Compiler plugin | apollo-kotlin-normalized-cache"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/compiler-plugin.html#webpage",
    "url": "writerside-documentation/compiler-plugin.html",
    "name": "Compiler plugin | apollo-kotlin-normalized-cache",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "apollo-kotlin-normalized-cache Help"
}</script><!-- End Schema.org --></head><body data-id="compiler-plugin" data-main-title="Compiler plugin" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="" data-edit-url="https://github.com/apollographql/apollo-kotlin-normalized-cache/edit/main/Writerside/topics/compiler-plugin.md"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>apollo-kotlin-normalized-cache  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="compiler-plugin" id="compiler-plugin.md">Compiler plugin</h1><p id="subtef_3">When setting up the Normalized Cache in your project, you need to configure the compiler plugin:</p><div class="code-block" data-lang="kotlin">
// build.gradle.kts
apollo {
  service(&quot;service&quot;) {
    // ...

    // Add this
    plugin(&quot;com.apollographql.cache:normalized-cache-apollo-compiler-plugin:1.0.0-alpha.4&quot;) {
      argument(&quot;packageName&quot;, packageName.get())
    }
  }
}
</div><p id="subtef_5">This plugin generates some code to support the Normalized Cache features, such as declarative cache IDs, pagination and cache control.</p><section class="chapter"><h2 id="declarative-cache-ids-typepolicy" data-toc="declarative-cache-ids-typepolicy">Declarative cache IDs (<code class="code" id="subtef_17">@typePolicy</code>)</h2><p id="subtef_10">You can refer to the <a href="https://www.apollographql.com/docs/kotlin/caching/declarative-ids" id="subtef_18" data-external="true" rel="noopener noreferrer">declarative cache IDs documentation</a> for a general overview of this feature.</p><p id="subtef_11">Here are some additional details of what the compiler plugin does to support it.</p><p id="subtef_12">Let's consider this schema for example:</p><div class="code-block" data-lang="graphql">
# schema.graphqls
type Query {
  user(id: ID!): User
}

type User {
  id: ID!
  email: String!
  name: String!
}
</div><div class="code-block" data-lang="graphql">
# extra.graphqls
extend type User @typePolicy(keyFields: &quot;id&quot;)
</div><section class="chapter"><h3 id="generation-of-typepolicies" data-toc="generation-of-typepolicies">Generation of <code class="code" id="subtef_26">typePolicies</code></h3><p id="subtef_20">A map of type names to <code class="code" id="subtef_27">TypePolicy</code> instances is generated in a <code class="code" id="subtef_28">Cache</code> object.</p><p id="subtef_21">In the example above, the generated code will look like this:</p><div class="code-block" data-lang="kotlin">
object cache {
  val typePolicies: Map&lt;String, TypePolicy&gt; = mapOf(
      &quot;User&quot; to TypePolicy(keyFields = setOf(&quot;id&quot;))
  )
}

</div><p id="subtef_23">This map is passed to the <code class="code" id="subtef_29">TypePolicyCacheKeyGenerator</code> when calling <a href="#cache-extension-function" id="subtef_30" data-tooltip="An ApolloClient.Builder.cache() extension function is generated by the compiler plugin, which configures the CacheKeyGenerator, MetadataGenerator, CacheResolver, and RecordMerger based on the type policies, connection types, and max ages configured in the schema:">the <code class="code" id="subtef_31">cache()</code> extension</a>.</p><p id="subtef_24">If you need more control over the configuration, use the <code class="code" id="subtef_32">normalizedCache()</code> extension and pass this map to the <code class="code" id="subtef_33">TypePolicyCacheKeyGenerator</code>:</p><div class="code-block" data-lang="kotlin">
val apolloClient = ApolloClient.Builder()
    // ...
    .normalizedCache(
        // ...
        cacheKeyGenerator = TypePolicyCacheKeyGenerator(Cache.typePolicies)
    )
    .build()
</div></section><section class="chapter"><h3 id="addition-of-key-fields-and-typename-to-selections" data-toc="addition-of-key-fields-and-typename-to-selections">Addition of key fields and <code class="code" id="subtef_44">__typename</code> to selections</h3><p id="subtef_35">The compiler automatically adds the key fields declared with <code class="code" id="subtef_45">@typePolicy</code> to the selections that return that type. This is to ensure that a <code class="code" id="subtef_46">CacheKey</code> can be generated for the record.</p><p id="subtef_36">When you query for <code class="code" id="subtef_47">User</code>, e.g.:</p><div class="code-block" data-lang="graphql">
# operations.graphql
query User {
  user(id: &quot;1&quot;) {
    email
    name
  }
}
</div><p id="subtef_38">The compiler plugin will automatically add the <code class="code" id="subtef_48">id</code> and <code class="code" id="subtef_49">__typename</code> fields to the selection set, resulting in:</p><div class="code-block" data-lang="graphql">
query User {
  user(id: &quot;1&quot;) {
    __typename # Added by the compiler plugin
    email
    name
    id # Added by the compiler plugin
  }
}
</div><p id="subtef_40">Now, <a href="https://apollographql.github.io/apollo-kotlin-normalized-cache/kdoc/normalized-cache/com.apollographql.cache.normalized.api/-type-policy-cache-key-generator.html?query=fun%20TypePolicyCacheKeyGenerator(typePolicies:%20Map%3CString,%20TypePolicy%3E,%20keyScope:%20CacheKey.Scope%20=%20CacheKey.Scope.TYPE):%20CacheKeyGenerator" id="subtef_50" data-external="true" rel="noopener noreferrer">TypePolicyCacheKeyGenerator</a> can use the value of <code class="code" id="subtef_51">__typename</code> as the type of the returned object, and from that see that there is one key field, <code class="code" id="subtef_52">id</code>, for that type.</p><p id="subtef_41">From that it can return <code class="code" id="subtef_53">User:42</code> as the cache key for that record.</p><aside class="prompt" data-type="tip" data-title="" id="subtef_42"><p id="subtef_54">If your schema has ids that are unique across the service, you can pass <code class="code" id="subtef_56">CacheKey.Scope.SERVICE</code> to the <a href="#cache-extension-function" id="subtef_57" data-tooltip="An ApolloClient.Builder.cache() extension function is generated by the compiler plugin, which configures the CacheKeyGenerator, MetadataGenerator, CacheResolver, and RecordMerger based on the type policies, connection types, and max ages configured in the schema:"><code class="code" id="subtef_59">cache()</code></a> extension or <code class="code" id="subtef_58">TypePolicyCacheKeyGenerator</code> constructor to save space in the cache.</p><p id="subtef_55">In that example the cache key would be <code class="code" id="subtef_60">42</code> instead of <code class="code" id="subtef_61">User:42</code>.</p></aside><section class="chapter"><h4 id="unions-and-interfaces" data-toc="unions-and-interfaces">Unions and interfaces</h4><p id="subtef_62">Let's consider this example:</p><div class="code-block" data-lang="graphql">
# schema.graphqls
type Query {
  search(text: String!): [SearchResult!]!
}

type Product {
  shopId: String!
  productId: String!
  description: String!
}

type Book {
  isbn: ID!
  title: String!
}

union SearchResult = User | Post
</div><div class="code-block" data-lang="graphql">
# extra.graphqls
extend type Product @typePolicy(keyFields: &quot;shopId productId&quot;)
extend type Book @typePolicy(keyFields: &quot;isbn&quot;)
</div><div class="code-block" data-lang="graphql">
# operations.graphql
query Search($text: String!) {
  search(text: $text) {
    ... on Book {
      title
    }
  }
}
</div><p id="subtef_66">The plugin needs to add the key fields of all possible types of <code class="code" id="subtef_72">SearchResult</code>, like so:</p><div class="code-block" data-lang="graphql">
query Search($text: String!) {
  search(text: $text) {
    __typename # Added by the compiler plugin
    ... on Book {
      title
    }
    # Added by the compiler plugin
    ... on Book {
      isbn
    }
    ... on Product {
      shopId
      productId
    }
  }
}
</div><p id="subtef_68">The principle is the same with interfaces, for instance:</p><div class="code-block" data-lang="graphql">
# schema.graphqls
type Query {
  search(text: String!): [SearchResult!]!
}

interface SearchResult {
  summary: String!
}

type Product implements SearchResult {
  summary: String!
  shopId: String!
  productId: String!
}

type Book implements SearchResult {
  summary: String!
  isbn: ID!
  title: String!
}
</div><p id="subtef_70">The modified query would look the same as above, with the key fields of <code class="code" id="subtef_73">Product</code> and <code class="code" id="subtef_74">Book</code> added to the selection set.</p><aside class="prompt" data-type="tip" data-title="" id="subtef_71"><p id="subtef_75">If key fields are defined on the interface itself, they only need to be added once, instead of once per possible type.</p></aside></section></section></section><section class="chapter"><h2 id="resolving-to-cache-keys-fieldpolicy" data-toc="resolving-to-cache-keys-fieldpolicy">Resolving to cache keys (<code class="code" id="subtef_83">@fieldPolicy</code>)</h2><p id="subtef_77">When a field returns a type that has key fields, and takes arguments that correspond to these keys, you can use the <code class="code" id="subtef_84">@fieldPolicy</code> directive.</p><p id="subtef_78">For instance,</p><div class="code-block" data-lang="graphql">
# schema.graphqls
type Query {
  user(id: ID!): User
}

type User {
  id: ID!
  email: String!
  name: String!
}
</div><div class="code-block" data-lang="graphql">
# extra.graphqls
extend type User @typePolicy(keyFields: &quot;id&quot;)

extend type Query @fieldPolicy(forField: &quot;user&quot;, keyArgs: &quot;id&quot;)
</div><p id="subtef_81">From this, when selecting e.g. <code class="code" id="subtef_85">user(id: 42)</code> the <code class="code" id="subtef_86">FieldPolicyCacheResolver</code> knows to return <code class="code" id="subtef_87">User:42</code> as a <code class="code" id="subtef_88">CacheKey</code>, thus saving a network request if the record is already in the cache.</p><section class="chapter"><h3 id="field-policy-unions-and-interfaces" data-toc="field-policy-unions-and-interfaces">Unions and interfaces</h3><p id="subtef_89">If a field returns a union or interface it is not possible to know which concrete type will be returned at runtime, and thus prefixing the cache key with the correct type name is not possible. A network call can't be avoided here.</p><p id="subtef_90">However, if your schema has ids that are unique across the service, you can pass <code class="code" id="subtef_91">CacheKey.Scope.SERVICE</code> to the <a href="#cache-extension-function" id="subtef_92" data-tooltip="An ApolloClient.Builder.cache() extension function is generated by the compiler plugin, which configures the CacheKeyGenerator, MetadataGenerator, CacheResolver, and RecordMerger based on the type policies, connection types, and max ages configured in the schema:"><code class="code" id="subtef_94">cache()</code></a> extension or <code class="code" id="subtef_93">FieldPolicyCacheResolver</code> constructor to skip the type name in the cache key. Network call avoidance will work in that case.</p></section></section><section class="chapter"><h2 id="cache-extension-function" data-toc="cache-extension-function"><code class="code" id="subtef_99">cache()</code> extension function</h2><p id="subtef_96">An <code class="code" id="subtef_100">ApolloClient.Builder.cache()</code> extension function is generated by the compiler plugin, which configures the <code class="code" id="subtef_101">CacheKeyGenerator</code>, <code class="code" id="subtef_102">MetadataGenerator</code>, <code class="code" id="subtef_103">CacheResolver</code>, and <code class="code" id="subtef_104">RecordMerger</code> based on the type policies, connection types, and <a href="cache-control.html" id="subtef_105" data-tooltip="The cache control feature takes the freshness of fields into consideration when accessing the cache. This is also sometimes referred to as TTL (Time To Live) or expiration.">max ages</a> configured in the schema:</p><div class="code-block" data-lang="kotlin">
val apolloClient = ApolloClient.Builder()
    // ...
    .cache(cacheFactory = /*...*/)
    .build()
</div><p id="subtef_98">Optionally pass a <code class="code" id="subtef_106">defaultMaxAge</code> (infinity by default) and <code class="code" id="subtef_107">keyScope</code> (<code class="code" id="subtef_108">CacheKey.Scope.TYPE</code> by default).</p></section><div class="last-modified">Last modified: 30 June 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="partial-cache-reads.html" class="navigation-links__prev">Partial cache reads</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b575/app.js"></script></body></html>