<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-06-23T08:46:49.743063343"><title>Compiler plugin | apollo-kotlin-normalized-cache</title><script type="application/json" id="virtual-toc-data">[{"id":"declarative-cache-ids-typepolicy","level":0,"title":"Declarative cache IDs (@typePolicy)","anchor":"#declarative-cache-ids-typepolicy"},{"id":"resolving-to-cache-keys-fieldpolicy","level":0,"title":"Resolving to cache keys (@fieldPolicy)","anchor":"#resolving-to-cache-keys-fieldpolicy"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b575/app.css" rel="stylesheet"><link href="static/custom.css" rel="stylesheet"><link rel="icon" type="image/png" sizes="16x16" href="images/favicon-96x96.png"><link rel="icon" type="image/png" sizes="32x32" href="images/favicon-192x192.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Compiler plugin | apollo-kotlin-normalized-cache"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="apollo-kotlin-normalized-cache Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/compiler-plugin.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Compiler plugin | apollo-kotlin-normalized-cache"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/compiler-plugin.html#webpage",
    "url": "writerside-documentation/compiler-plugin.html",
    "name": "Compiler plugin | apollo-kotlin-normalized-cache",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "apollo-kotlin-normalized-cache Help"
}</script><!-- End Schema.org --></head><body data-id="compiler-plugin" data-main-title="Compiler plugin" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="" data-edit-url="https://github.com/apollographql/apollo-kotlin-normalized-cache/edit/main/Writerside/topics/compiler-plugin.md"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>apollo-kotlin-normalized-cache  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="compiler-plugin" id="compiler-plugin.md">Compiler plugin</h1><p id="op59q1_3">When setting up the Normalized Cache in your project, you need to configure the compiler plugin:</p><div class="code-block" data-lang="kotlin">
// build.gradle.kts
apollo {
  service(&quot;service&quot;) {
    // ...

    // Add this
    plugin(&quot;com.apollographql.cache:normalized-cache-apollo-compiler-plugin:1.0.0-alpha.3&quot;) {
      argument(&quot;packageName&quot;, packageName.get())
    }
  }
}
</div><p id="op59q1_5">This plugin generates some code to support the Normalized Cache features, such as declarative cache IDs, pagination and cache control.</p><section class="chapter"><h2 id="declarative-cache-ids-typepolicy" data-toc="declarative-cache-ids-typepolicy">Declarative cache IDs (<code class="code" id="op59q1_16">@typePolicy</code>)</h2><p id="op59q1_9">You can refer to the <a href="https://www.apollographql.com/docs/kotlin/caching/declarative-ids" id="op59q1_17" data-external="true" rel="noopener noreferrer">declarative cache IDs documentation</a> for a general overview of this feature.</p><p id="op59q1_10">Here are some additional details of what the compiler plugin does to support it.</p><p id="op59q1_11">Let's consider this schema for example:</p><div class="code-block" data-lang="graphql">
# schema.graphqls
type Query {
  user(id: ID!): User
}

type User {
  id: ID!
  email: String!
  name: String!
}
</div><div class="code-block" data-lang="graphql">
# extra.graphqls
extend type User @typePolicy(keyFields: &quot;id&quot;)
</div><section class="chapter"><h3 id="generation-of-typepolicies" data-toc="generation-of-typepolicies">Generation of <code class="code" id="op59q1_24">typePolicies</code></h3><p id="op59q1_19">A map of type names to <code class="code" id="op59q1_25">TypePolicy</code> instances is generated in a <code class="code" id="op59q1_26">Cache</code> object.</p><p id="op59q1_20">In the example above, the generated code will look like this:</p><div class="code-block" data-lang="kotlin">
object cache {
  val typePolicies: Map&lt;String, TypePolicy&gt; = mapOf(
      &quot;User&quot; to TypePolicy(keyFields = setOf(&quot;id&quot;))
  )
}

</div><p id="op59q1_22">Pass this map to the <code class="code" id="op59q1_27">TypePolicyCacheKeyGenerator</code> when configuring the cache:</p><div class="code-block" data-lang="kotlin">
val apolloClient = ApolloClient.Builder()
    // ...
    .normalizedCache(
        // ...
        cacheKeyGenerator = TypePolicyCacheKeyGenerator(Cache.typePolicies)
    )
    .build()
</div></section><section class="chapter"><h3 id="addition-of-key-fields-and-typename-to-selections" data-toc="addition-of-key-fields-and-typename-to-selections">Addition of key fields and <code class="code" id="op59q1_38">__typename</code> to selections</h3><p id="op59q1_29">The compiler automatically adds the key fields declared with <code class="code" id="op59q1_39">@typePolicy</code> to the selections that return that type. This is to ensure that a <code class="code" id="op59q1_40">CacheKey</code> can be generated for the record.</p><p id="op59q1_30">When you query for <code class="code" id="op59q1_41">User</code>, e.g.:</p><div class="code-block" data-lang="graphql">
# operations.graphql
query User {
  user(id: &quot;1&quot;) {
    email
    name
  }
}
</div><p id="op59q1_32">The compiler plugin will automatically add the <code class="code" id="op59q1_42">id</code> and <code class="code" id="op59q1_43">__typename</code> fields to the selection set, resulting in:</p><div class="code-block" data-lang="graphql">
query User {
  user(id: &quot;1&quot;) {
    __typename # Added by the compiler plugin
    email
    name
    id # Added by the compiler plugin
  }
}
</div><p id="op59q1_34">Now, <a href="https://apollographql.github.io/apollo-kotlin-normalized-cache/kdoc/normalized-cache/com.apollographql.cache.normalized.api/-type-policy-cache-key-generator.html?query=fun%20TypePolicyCacheKeyGenerator(typePolicies:%20Map%3CString,%20TypePolicy%3E,%20keyScope:%20CacheKey.Scope%20=%20CacheKey.Scope.TYPE):%20CacheKeyGenerator" id="op59q1_44" data-external="true" rel="noopener noreferrer">TypePolicyCacheKeyGenerator</a> can use the value of <code class="code" id="op59q1_45">__typename</code> as the type of the returned object, and from that see that there is one key field, <code class="code" id="op59q1_46">id</code>, for that type.</p><p id="op59q1_35">From that it can return <code class="code" id="op59q1_47">User:42</code> as the cache key for that record.</p><aside class="prompt" data-type="tip" data-title="" id="op59q1_36"><p id="op59q1_48">If your schema has ids that are unique across the service, you can pass <code class="code" id="op59q1_50">CacheKey.Scope.SERVICE</code> to the <code class="code" id="op59q1_51">TypePolicyCacheKeyGenerator</code> constructor to save space in the cache.</p><p id="op59q1_49">In that example the cache key would be <code class="code" id="op59q1_52">42</code> instead of <code class="code" id="op59q1_53">User:42</code>.</p></aside><section class="chapter"><h4 id="unions-and-interfaces" data-toc="unions-and-interfaces">Unions and interfaces</h4><p id="op59q1_54">Let's consider this example:</p><div class="code-block" data-lang="graphql">
# schema.graphqls
type Query {
  search(text: String!): [SearchResult!]!
}

type Product {
  shopId: String!
  productId: String!
  description: String!
}

type Book {
  isbn: ID!
  title: String!
}

union SearchResult = User | Post
</div><div class="code-block" data-lang="graphql">
# extra.graphqls
extend type Product @typePolicy(keyFields: &quot;shopId productId&quot;)
extend type Book @typePolicy(keyFields: &quot;isbn&quot;)
</div><div class="code-block" data-lang="graphql">
# operations.graphql
query Search($text: String!) {
  search(text: $text) {
    ... on Book {
      title
    }
  }
}
</div><p id="op59q1_58">The plugin needs to add the key fields of all possible types of <code class="code" id="op59q1_64">SearchResult</code>, like so:</p><div class="code-block" data-lang="graphql">
query Search($text: String!) {
  search(text: $text) {
    __typename # Added by the compiler plugin
    ... on Book {
      title
    }
    # Added by the compiler plugin
    ... on Book {
      isbn
    }
    ... on Product {
      shopId
      productId
    }
  }
}
</div><p id="op59q1_60">The principle is the same with interfaces, for instance:</p><div class="code-block" data-lang="graphql">
# schema.graphqls
type Query {
  search(text: String!): [SearchResult!]!
}

interface SearchResult {
  summary: String!
}

type Product implements SearchResult {
  summary: String!
  shopId: String!
  productId: String!
}

type Book implements SearchResult {
  summary: String!
  isbn: ID!
  title: String!
}
</div><p id="op59q1_62">The modified query would look the same as above, with the key fields of <code class="code" id="op59q1_65">Product</code> and <code class="code" id="op59q1_66">Book</code> added to the selection set.</p><aside class="prompt" data-type="tip" data-title="" id="op59q1_63"><p id="op59q1_67">If key fields are defined on the interface itself, they only need to be added once, instead of once per possible type.</p></aside></section></section></section><section class="chapter"><h2 id="resolving-to-cache-keys-fieldpolicy" data-toc="resolving-to-cache-keys-fieldpolicy">Resolving to cache keys (<code class="code" id="op59q1_75">@fieldPolicy</code>)</h2><p id="op59q1_69">When a field returns a type that has key fields, and takes arguments that correspond to these keys, you can use the <code class="code" id="op59q1_76">@fieldPolicy</code> directive.</p><p id="op59q1_70">For instance,</p><div class="code-block" data-lang="graphql">
# schema.graphqls
type Query {
  user(id: ID!): User
}

type User {
  id: ID!
  email: String!
  name: String!
}
</div><div class="code-block" data-lang="graphql">
# extra.graphqls
extend type User @typePolicy(keyFields: &quot;id&quot;)

extend type Query @fieldPolicy(forField: &quot;user&quot;, keyArgs: &quot;id&quot;)
</div><p id="op59q1_73">From this, when selecting e.g. <code class="code" id="op59q1_77">user(id: 42)</code> the <code class="code" id="op59q1_78">FieldPolicyCacheResolver</code> knows to return <code class="code" id="op59q1_79">User:42</code> as a <code class="code" id="op59q1_80">CacheKey</code>, thus saving a network request if the record is already in the cache.</p><section class="chapter"><h3 id="field-policy-unions-and-interfaces" data-toc="field-policy-unions-and-interfaces">Unions and interfaces</h3><p id="op59q1_81">If a field returns a union or interface it is not possible to know which concrete type will be returned at runtime, and thus prefixing the cache key with the correct type name is not possible. Avoiding a network call is not possible here.</p><p id="op59q1_82">However, if your schema has ids that are unique across the service, you can pass <code class="code" id="op59q1_83">CacheKey.Scope.SERVICE</code> to the <code class="code" id="op59q1_84">FieldPolicyCacheResolver</code> constructor to skip the type name in the cache key. Network call avoidance will still work in that case.</p></section></section><div class="last-modified">Last modified: 17 June 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="trimming.html" class="navigation-links__prev">Trimming the cache</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b575/app.js"></script></body></html>