@file:OptIn(ApolloExperimental::class)

package com.apollographql.cache.apollocompilerplugin.internal

import com.apollographql.apollo.annotations.ApolloExperimental
import com.apollographql.apollo.ast.GQLDocument
import com.apollographql.apollo.ast.Schema
import com.apollographql.apollo.ast.toSchema
import com.apollographql.apollo.compiler.ApolloCompiler
import com.apollographql.apollo.compiler.ApolloCompilerPluginEnvironment
import com.apollographql.apollo.compiler.ApolloCompilerPluginLogger
import com.apollographql.apollo.compiler.SchemaCodeGenerator
import com.apollographql.cache.apollocompilerplugin.VERSION
import com.squareup.kotlinpoet.BOOLEAN
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.MAP
import com.squareup.kotlinpoet.MemberName
import com.squareup.kotlinpoet.ParameterSpec
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.SET
import com.squareup.kotlinpoet.STRING
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.asTypeName
import com.squareup.kotlinpoet.withIndent
import java.io.File
import kotlin.time.Duration

private object Symbols {
  val MaxAge = ClassName("com.apollographql.cache.normalized.api", "MaxAge")
  val MaxAgeInherit = MaxAge.nestedClass("Inherit")
  val MaxAgeDuration = MaxAge.nestedClass("Duration")
  val Seconds = MemberName(Duration.Companion::class.asTypeName(), "seconds", isExtension = true)
  val TypePolicy = ClassName("com.apollographql.cache.normalized.api", "TypePolicy")
  val EmbeddedFields = ClassName("com.apollographql.cache.normalized.api", "EmbeddedFields")
  val ApolloClientBuilder = ClassName("com.apollographql.apollo", "ApolloClient", "Builder")
  val NormalizedCacheFactory = ClassName("com.apollographql.cache.normalized.api", "NormalizedCacheFactory")
  val CacheKeyScope = ClassName("com.apollographql.cache.normalized.api", "CacheKey", "Scope")
  val KotlinDuration = Duration::class.asTypeName()
  val NormalisedCacheExtension = MemberName("com.apollographql.cache.normalized", "normalizedCache", isExtension = true)
}

internal class CacheSchemaCodeGenerator(
    private val environment: ApolloCompilerPluginEnvironment,
) : SchemaCodeGenerator {
  override fun generate(schema: GQLDocument, outputDirectory: File) {
    val validSchema = schema.toSchema()
    if (environment.arguments.contains("packageName")) {
      environment.logger().warning(
          "The Cache compiler plugin 'packageName' argument is deprecated. Please use 'com.apollographql.cache.packageName' instead."
      )
    }
    val packageName = (
        environment.arguments["com.apollographql.cache.packageName"] as? String
        // Fallback to the old argument name for compatibility with pre-v1.0.0 versions
            ?: environment.arguments["packageName"] as? String
            ?: throw IllegalArgumentException("com.apollographql.cache.packageName argument is required and must be a String")) + ".cache"
    val typePolicies = validSchema.getTypePolicies()
    val connectionTypes = validSchema.getConnectionTypes()
    val embeddedFields = validSchema.getEmbeddedFields(typePolicies, connectionTypes)
    val file = FileSpec.builder(packageName, "Cache")
        .addType(
            TypeSpec.objectBuilder("Cache")
                .addProperty(maxAgeProperty(validSchema))
                .addProperty(typePoliciesProperty(typePolicies))
                .addProperty(embeddedFieldsProperty(embeddedFields))
                .addProperty(connectionTypesProperty(connectionTypes))
                .addFunction(cacheFunction())
                .build()
        )
        .addFileComment(
            """
                
                AUTO-GENERATED FILE. DO NOT MODIFY.
                
                This class was automatically generated by Apollo GraphQL Cache version '$VERSION'.
                
            """.trimIndent()
        )
        .build()
    file.writeTo(outputDirectory)
  }

  private fun ApolloCompilerPluginEnvironment.logger(): ApolloCompiler.Logger {
    val method = this::class.java.methods.first { it.name == "getLogger" }
    if (method.returnType.name == "com.apollographql.apollo.compiler.ApolloCompiler\$Logger") {
      /**
       * The code is running on v5 where logger was converted to return directly ApolloCompiler.Logger.
       *
       * See https://github.com/apollographql/apollo-kotlin-normalized-cache/pull/178
       */
      return method.invoke(this) as ApolloCompiler.Logger
    }

    return logger.toApolloCompilerLogger()
  }

  private fun ApolloCompilerPluginLogger.toApolloCompilerLogger(): ApolloCompiler.Logger {
    return object : ApolloCompiler.Logger {
      override fun warning(message: String) {
        return this@toApolloCompilerLogger.error(message)
      }
    }
  }

  private fun maxAgeProperty(schema: Schema): PropertySpec {
    val maxAges = schema.getMaxAges(environment.logger())
    val initializer = if (maxAges.isEmpty()) {
      CodeBlock.of("emptyMap()")
    } else {
      CodeBlock.builder().apply {
        add("mapOf(\n")
        withIndent {
          maxAges.forEach { (field, duration) ->
            if (duration == -1) {
              addStatement("%S to %T,", field, Symbols.MaxAgeInherit)
            } else {
              addStatement("%S to %T(%L.%M),", field, Symbols.MaxAgeDuration, duration, Symbols.Seconds)
            }
          }
        }
        add(")")
      }
          .build()
    }
    return PropertySpec.builder(
        name = "maxAges",
        type = MAP.parameterizedBy(STRING, Symbols.MaxAge)
    )
        .initializer(initializer)
        .build()
  }

  private fun typePoliciesProperty(typePolicies: Map<String, TypePolicy>): PropertySpec {
    val typePolicies = typePolicies.filter { it.value.keyFields.isNotEmpty() }
    val initializer = if (typePolicies.isEmpty()) {
      CodeBlock.of("emptyMap()")
    } else {
      CodeBlock.builder().apply {
        add("mapOf(\n")
        withIndent {
          typePolicies.forEach { (type, typePolicy) ->
            addStatement("%S to %T(", type, Symbols.TypePolicy)
            withIndent {
              addStatement("keyFields = setOf(")
              withIndent {
                typePolicy.keyFields.sorted().forEach { keyField ->
                  addStatement("%S, ", keyField)
                }
              }
              add("),\n")
            }
            addStatement("),")
          }
        }
        add(")")
      }
          .build()
    }
    return PropertySpec.builder(
        name = "typePolicies",
        type = MAP.parameterizedBy(STRING, Symbols.TypePolicy)
    )
        .initializer(initializer)
        .build()
  }

  private fun connectionTypesProperty(connectionTypes: Set<String>): PropertySpec {
    val initializer = if (connectionTypes.isEmpty()) {
      CodeBlock.of("emptySet()")
    } else {
      CodeBlock.builder().apply {
        add("setOf(\n")
        withIndent {
          connectionTypes.forEach { connectionType ->
            addStatement("%S,", connectionType)
          }
        }
        add(")")
      }
          .build()
    }
    return PropertySpec.builder(
        name = "connectionTypes",
        type = SET.parameterizedBy(STRING)
    )
        .initializer(initializer)
        .build()
  }

  private fun embeddedFieldsProperty(embeddedFields: Map<String, EmbeddedFields>): PropertySpec {
    val initializer = if (embeddedFields.isEmpty()) {
      CodeBlock.of("emptyMap()")
    } else {
      CodeBlock.builder().apply {
        add("mapOf(\n")
        withIndent {
          embeddedFields.forEach { (type, embeddedField) ->
            addStatement("%S to %T(", type, Symbols.EmbeddedFields)
            withIndent {
              addStatement("embeddedFields = setOf(")
              withIndent {
                embeddedField.embeddedFields.forEach { embeddedField ->
                  addStatement("%S, ", embeddedField)
                }
              }
              add("),\n")
            }
            addStatement("),")
          }
        }
        add(")")
      }
          .build()
    }
    return PropertySpec.builder(
        name = "embeddedFields",
        type = MAP.parameterizedBy(STRING, Symbols.EmbeddedFields)
    )
        .initializer(initializer)
        .build()
  }

  private fun cacheFunction(): FunSpec {
    return FunSpec.builder("cache")
        .receiver(Symbols.ApolloClientBuilder)
        .addParameter("normalizedCacheFactory", Symbols.NormalizedCacheFactory)
        .addParameter(ParameterSpec.builder("keyScope", Symbols.CacheKeyScope)
            .defaultValue("CacheKey.Scope.TYPE").build()
        )
        .addParameter(ParameterSpec.builder("defaultMaxAge", Symbols.KotlinDuration)
            .defaultValue("%T.INFINITE", Symbols.KotlinDuration)
            .build()
        )
        .addParameter(ParameterSpec.builder("enableOptimisticUpdates", BOOLEAN)
            .defaultValue("false")
            .build()
        )
        .addParameter(ParameterSpec.builder("writeToCacheAsynchronously", BOOLEAN)
            .defaultValue("false")
            .build()
        )
        .returns(Symbols.ApolloClientBuilder)
        .addCode(
            CodeBlock.builder()
                .addStatement(
                    "return %M(\nâ‡¥" +
                        "normalizedCacheFactory = normalizedCacheFactory,\n" +
                        "typePolicies = typePolicies,\n" +
                        "connectionTypes = connectionTypes, \n" +
                        "embeddedFields = embeddedFields, \n" +
                        "maxAges = maxAges,\n" +
                        "defaultMaxAge = defaultMaxAge,\n" +
                        "keyScope = keyScope,\n" +
                        "enableOptimisticUpdates = enableOptimisticUpdates,\n" +
                        "writeToCacheAsynchronously = writeToCacheAsynchronously,\nâ‡¤" +
                        ")",
                    Symbols.NormalisedCacheExtension,
                )
                .build()
        )
        .build()
  }
}
