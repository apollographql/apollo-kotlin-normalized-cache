@file:OptIn(ApolloExperimental::class)

package com.apollographql.cache.apollocompilerplugin.internal

import com.apollographql.apollo.annotations.ApolloExperimental
import com.apollographql.apollo.ast.GQLDocument
import com.apollographql.apollo.ast.GQLInterfaceTypeDefinition
import com.apollographql.apollo.ast.GQLObjectTypeDefinition
import com.apollographql.apollo.ast.GQLStringValue
import com.apollographql.apollo.ast.GQLUnionTypeDefinition
import com.apollographql.apollo.ast.Schema
import com.apollographql.apollo.ast.Schema.Companion.TYPE_POLICY
import com.apollographql.apollo.ast.toSchema
import com.apollographql.apollo.compiler.ApolloCompiler
import com.apollographql.apollo.compiler.ApolloCompilerPluginEnvironment
import com.apollographql.apollo.compiler.ApolloCompilerPluginLogger
import com.apollographql.apollo.compiler.SchemaCodeGenerator
import com.apollographql.cache.apollocompilerplugin.VERSION
import com.squareup.kotlinpoet.BOOLEAN
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.MAP
import com.squareup.kotlinpoet.MemberName
import com.squareup.kotlinpoet.ParameterSpec
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.SET
import com.squareup.kotlinpoet.STRING
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.asTypeName
import com.squareup.kotlinpoet.withIndent
import java.io.File
import kotlin.time.Duration

private object Symbols {
  val MaxAge = ClassName("com.apollographql.cache.normalized.api", "MaxAge")
  val MaxAgeInherit = MaxAge.nestedClass("Inherit")
  val MaxAgeDuration = MaxAge.nestedClass("Duration")
  val Seconds = MemberName(Duration.Companion::class.asTypeName(), "seconds", isExtension = true)
  val TypePolicy = ClassName("com.apollographql.cache.normalized.api", "TypePolicy")
  val ApolloClientBuilder = ClassName("com.apollographql.apollo", "ApolloClient", "Builder")
  val NormalizedCacheFactory = ClassName("com.apollographql.cache.normalized.api", "NormalizedCacheFactory")
  val CacheKeyScope = ClassName("com.apollographql.cache.normalized.api", "CacheKey", "Scope")
  val KotlinDuration = Duration::class.asTypeName()
  val NormalisedCacheExtension = MemberName("com.apollographql.cache.normalized", "normalizedCache", isExtension = true)
}

internal class CacheSchemaCodeGenerator(
    private val environment: ApolloCompilerPluginEnvironment,
) : SchemaCodeGenerator {
  override fun generate(schema: GQLDocument, outputDirectory: File) {
    val validSchema = schema.toSchema()
    val packageName = (environment.arguments["packageName"] as? String
        ?: throw IllegalArgumentException("packageName argument is required and must be a String")) + ".cache"
    val file = FileSpec.builder(packageName, "Cache")
        .addType(
            TypeSpec.objectBuilder("Cache")
                .addProperty(maxAgeProperty(validSchema))
                .addProperty(typePoliciesProperty(validSchema))
                .addProperty(connectionTypesProperty(validSchema, packageName))
                .addFunction(cacheFunction(validSchema))
                .build()
        )
        .addFileComment(
            """
                
                AUTO-GENERATED FILE. DO NOT MODIFY.
                
                This class was automatically generated by Apollo GraphQL Cache version '$VERSION'.
                
            """.trimIndent()
        )
        .build()
    file.writeTo(outputDirectory)
  }

  private fun ApolloCompilerPluginEnvironment.logger(): ApolloCompiler.Logger {
    val method = this::class.java.methods.first { it.name == "getLogger" }
    if (method.returnType.name == "com.apollographql.apollo.compiler.ApolloCompiler\$Logger") {
      /**
       * The code is running on v5 where logger was converted to return directly ApolloCompiler.Logger.
       *
       * See https://github.com/apollographql/apollo-kotlin-normalized-cache/pull/178
       */
      return method.invoke(this) as ApolloCompiler.Logger
    }

    return logger.toApolloCompilerLogger()
  }

  private fun ApolloCompilerPluginLogger.toApolloCompilerLogger(): ApolloCompiler.Logger {
    return object : ApolloCompiler.Logger {
      override fun warning(message: String) {
        return this@toApolloCompilerLogger.error(message)
      }
    }
  }

  private fun maxAgeProperty(schema: Schema): PropertySpec {
    val maxAges = schema.getMaxAges(environment.logger())
    val initializer = CodeBlock.builder().apply {
      add("mapOf(\n")
      withIndent {
        maxAges.forEach { (field, duration) ->
          if (duration == -1) {
            addStatement("%S to %T,", field, Symbols.MaxAgeInherit)
          } else {
            addStatement("%S to %T(%L.%M),", field, Symbols.MaxAgeDuration, duration, Symbols.Seconds)
          }
        }
      }
      add(")")
    }
        .build()
    return PropertySpec.Companion.builder(
        name = "maxAges",
        type = MAP.parameterizedBy(STRING, Symbols.MaxAge)
    )
        .initializer(initializer)
        .build()
  }

  private fun typePoliciesProperty(schema: Schema): PropertySpec {
    val typePolicies = schema.getTypePolicies()
    val initializer = CodeBlock.builder().apply {
      add("mapOf(\n")
      withIndent {
        typePolicies.forEach { (type, typePolicy) ->
          addStatement("%S to %T(", type, Symbols.TypePolicy)
          withIndent {
            addStatement("keyFields = setOf(")
            withIndent {
              typePolicy.keyFields.forEach { keyField ->
                addStatement("%S, ", keyField)
              }
            }
            add("),\n")
          }
          addStatement("),")
        }
      }
      add(")")
    }
        .build()
    return PropertySpec.builder(
        name = "typePolicies",
        type = MAP.parameterizedBy(STRING, Symbols.TypePolicy)
    )
        .initializer(initializer)
        .build()
  }

  private fun connectionTypesProperty(schema: Schema, packageName: String): PropertySpec {
    // TODO: connectionTypes is generated by the Apollo compiler for now, and we just reference it. Instead we should generate it here.
    val hasPagination = schema.hasConnectionFields()
    val initializer = if (hasPagination) {
      val paginationPackageName = packageName.substringBeforeLast(".") + ".pagination"
      CodeBlock.of("%T.connectionTypes", ClassName(paginationPackageName, "Pagination"))
    } else {
      CodeBlock.of("emptySet()")
    }
    return PropertySpec.builder(
        name = "connectionTypes",
        type = SET.parameterizedBy(STRING)
    )
        .initializer(initializer)
        .build()
  }

  private fun cacheFunction(validSchema: Schema): FunSpec {
    validSchema.hasConnectionFields()
    return FunSpec.builder("cache")
        .receiver(Symbols.ApolloClientBuilder)
        .addParameter("normalizedCacheFactory", Symbols.NormalizedCacheFactory)
        .addParameter(ParameterSpec.builder("keyScope", Symbols.CacheKeyScope)
            .defaultValue("CacheKey.Scope.TYPE").build()
        )
        .addParameter(ParameterSpec.builder("defaultMaxAge", Symbols.KotlinDuration)
            .defaultValue("%T.INFINITE", Symbols.KotlinDuration)
            .build()
        )
        .addParameter(ParameterSpec.builder("writeToCacheAsynchronously", BOOLEAN)
            .defaultValue("false")
            .build()
        )
        .returns(Symbols.ApolloClientBuilder)
        .addCode(
            CodeBlock.builder()
                .addStatement(
                    "return %M(\n⇥" +
                        "normalizedCacheFactory = normalizedCacheFactory,\n" +
                        "typePolicies = typePolicies,\n" +
                        "connectionTypes = connectionTypes, \n" +
                        "maxAges = maxAges,\n" +
                        "defaultMaxAge = defaultMaxAge,\n" +
                        "keyScope = keyScope,\n" +
                        "writeToCacheAsynchronously = writeToCacheAsynchronously,\n⇤" +
                        ")",
                    Symbols.NormalisedCacheExtension,
                )
                .build()
        )
        .build()
  }

  private fun Schema.hasConnectionFields(): Boolean {
    val directives = typeDefinitions.values.filterIsInstance<GQLObjectTypeDefinition>().flatMap { it.directives } +
        typeDefinitions.values.filterIsInstance<GQLInterfaceTypeDefinition>().flatMap { it.directives } +
        typeDefinitions.values.filterIsInstance<GQLUnionTypeDefinition>().flatMap { it.directives }
    return directives.any {
      originalDirectiveName(it.name) == TYPE_POLICY &&
          it.arguments.any { arg ->
            arg.name == "connectionFields" && !(arg.value as? GQLStringValue)?.value.isNullOrBlank()
          }
    }
  }
}
