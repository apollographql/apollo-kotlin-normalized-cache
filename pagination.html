<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2024-11-07T09:53:45.387432486"><title>Pagination | apollo-kotlin-normalized-cache-incubating</title><script type="application/json" id="virtual-toc-data">[{"id":"using-apollostore","level":0,"title":"Using ApolloStore","anchor":"#using-apollostore"},{"id":"using-the-incubating-pagination-support","level":0,"title":"Using the incubating pagination support","anchor":"#using-the-incubating-pagination-support"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b267/app.css" rel="stylesheet"><link rel="icon" type="image/png" sizes="16x16" href="images/favicon-96x96.png"><link rel="icon" type="image/png" sizes="32x32" href="images/favicon-192x192.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Pagination | apollo-kotlin-normalized-cache-incubating"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="apollo-kotlin-normalized-cache-incubating Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/pagination.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Pagination | apollo-kotlin-normalized-cache-incubating"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/pagination.html#webpage",
    "url": "writerside-documentation/pagination.html",
    "name": "Pagination | apollo-kotlin-normalized-cache-incubating",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "apollo-kotlin-normalized-cache-incubating Help"
}</script><!-- End Schema.org --></head><body data-id="pagination" data-main-title="Pagination" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="" data-edit-url="https://github.com/apollographql/apollo-kotlin-normalized-cache-incubating/edit/main/Writerside/topics/pagination.md"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>apollo-kotlin-normalized-cache-incubating  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="pagination" id="pagination.md">Pagination</h1><p id="-selosu_2">When using the normalized cache, objects are stored in records keyed by the object's id:</p><p id="-selosu_3">Query:</p><div class="code-block" data-lang="none">
query Users {
  allUsers(groupId: 2) {
    id
    name
  }
}
</div><p id="-selosu_5">Response:</p><div class="code-block" data-lang="json">
{
  &quot;data&quot;: {
    &quot;allUsers&quot;: [
      {
        &quot;id&quot;: 1,
        &quot;name&quot;: &quot;John Smith&quot;
      },
      {
        &quot;id&quot;: 2,
        &quot;name&quot;: &quot;Jane Doe&quot;
      }
    ]
  }
}
</div><p id="-selosu_7">Normalized cache:</p><div class="table-wrapper"><table class="wide" id="-selosu_8"><thead><tr class="ijRowHead" id="-selosu_9"><th id="-selosu_10"><p>Cache Key</p></th><th id="-selosu_11"><p>Record</p></th></tr></thead><tbody><tr id="-selosu_12"><td id="-selosu_13"><p>QUERY_ROOT</p></td><td id="-selosu_14"><p>allUsers(groupId: 2): [ref(user:1), ref(user:2)]</p></td></tr><tr id="-selosu_15"><td id="-selosu_16"><p>user:1</p></td><td id="-selosu_17"><p>id: 1, name: John Smith</p></td></tr><tr id="-selosu_18"><td id="-selosu_19"><p>user:2</p></td><td id="-selosu_20"><p>id: 2, name: Jane Doe</p></td></tr></tbody></table></div><p id="-selosu_21">The app can watch the <code class="code" id="-selosu_22">Users()</code> query and update the UI with the whole list when the data changes.</p><p id="-selosu_23">However with pagination things become less obvious:</p><p id="-selosu_24">Query:</p><div class="code-block" data-lang="none">
query UsersPage($page: Int!) {
  usersPage(groupId: 2, page: $page) {
    id
    name
  }
}
</div><p id="-selosu_26">Response:</p><div class="code-block" data-lang="json">
{
  &quot;data&quot;: {
    &quot;usersPage&quot;: [
      {
        &quot;id&quot;: 1,
        &quot;name&quot;: &quot;John Smith&quot;
      },
      {
        &quot;id&quot;: 2,
        &quot;name&quot;: &quot;Jane Doe&quot;
      }
    ]
  }
}
</div><p id="-selosu_28">Normalized cache:</p><div class="table-wrapper"><table class="wide" id="-selosu_29"><thead><tr class="ijRowHead" id="-selosu_30"><th id="-selosu_31"><p>Cache Key</p></th><th id="-selosu_32"><p>Record</p></th></tr></thead><tbody><tr id="-selosu_33"><td id="-selosu_34"><p>QUERY_ROOT</p></td><td id="-selosu_35"><p>usersPage(groupId: 2, page: 1): [ref(user:1), ref(user:2)]</p></td></tr><tr id="-selosu_36"><td id="-selosu_37"><p>user:1</p></td><td id="-selosu_38"><p>id: 1, name: John Smith</p></td></tr><tr id="-selosu_39"><td id="-selosu_40"><p>user:2</p></td><td id="-selosu_41"><p>id: 2, name: Jane Doe</p></td></tr></tbody></table></div><p id="-selosu_42">After fetching page 2, the cache will look like this:</p><div class="table-wrapper"><table class="wide" id="-selosu_43"><thead><tr class="ijRowHead" id="-selosu_44"><th id="-selosu_45"><p>Cache Key</p></th><th id="-selosu_46"><p>Record</p></th></tr></thead><tbody><tr id="-selosu_47"><td id="-selosu_48"><p>QUERY_ROOT</p></td><td id="-selosu_49"><p>usersPage(groupId: 2, page: 1): [ref(user:1), ref(user:2)], usersPage(groupId: 2, page: 2): [ref(user:3), ref(user:4)]</p></td></tr><tr id="-selosu_50"><td id="-selosu_51"><p>user:1</p></td><td id="-selosu_52"><p>id: 1, name: John Smith</p></td></tr><tr id="-selosu_53"><td id="-selosu_54"><p>user:2</p></td><td id="-selosu_55"><p>id: 2, name: Jane Doe</p></td></tr><tr id="-selosu_56"><td id="-selosu_57"><p>user:3</p></td><td id="-selosu_58"><p>id: 3, name: Peter Parker</p></td></tr><tr id="-selosu_59"><td id="-selosu_60"><p>user:4</p></td><td id="-selosu_61"><p>id: 4, name: Bruce Wayne</p></td></tr></tbody></table></div><p id="-selosu_62">Which query should the app watch to update the UI?</p><p id="-selosu_63">Watching <code class="code" id="-selosu_64">UsersPage(page = 1)</code> would only notify changes to the first page.</p><p id="-selosu_65">For the whole list to be reactive you'd need to watch the queries for each page, and update the corresponding segment of the list. While technically possible, this is cumbersome to implement.</p><p id="-selosu_66">You could skip watching altogether and only update the list when scrolling to its end, but that would mean that changes to individual items would not be reflected in the list UI.</p><p id="-selosu_67">What we need is having the whole list in a single record, so we can watch a single query.</p><section class="chapter"><h2 id="using-apollostore" data-toc="using-apollostore">Using ApolloStore</h2><p id="-selosu_68">The cache can be updated manually using the <code class="code" id="-selosu_69">ApolloStore</code> class.</p><div class="code-block" data-lang="kotlin">
suspend fun fetchAndMergePage(nextPage: Int) {
  // 1. Get the current list from the cache
  val listQuery = UsersPageQuery(page = 1)
  val cacheResponse = apolloClient.query(listQuery).fetchPolicy(FetchPolicy.CacheOnly).execute()

  // 2. Fetch the next page from the network (don't update the cache yet)
  val networkResponse = apolloClient.query(UsersPageQuery(page = nextPage)).fetchPolicy(FetchPolicy.NetworkOnly).execute()

  // 3. Merge the next page with the current list
  val mergedList = cacheResponse.data.usersPage.items + networkResponse.data.usersPage.items
  val dataWithMergedList = networkResponse.data.copy(
      usersPage = networkResponse.data.usersPage.copy(
          items = mergedList
      )
  )

  // 4. Update the cache with the merged list
  val keys = apolloClient.apolloStore.writeOperation(operation = listQuery, operationData = dataWithMergedList)
  apolloClient.apolloStore.publish(keys)
}
</div><p id="-selosu_71">Note that in this simple example, we need to remember the last fetched page, so we can know which page to fetch next. This can be stored in shared preferences for instance. However in most cases the API can return a &quot;page info&quot; object containing the information needed to fetch the next page, and this can be stored in the cache with the rest of the data.</p><p id="-selosu_72">An example of doing this is available <a href="https://github.com/apollographql/apollo-kotlin-normalized-cache-incubating/tree/main/samples/pagination/manual" id="-selosu_73" data-external="true" rel="noopener noreferrer">here</a>.</p></section><section class="chapter"><h2 id="using-the-incubating-pagination-support" data-toc="using-the-incubating-pagination-support">Using the incubating pagination support</h2><section class="chapter"><h3 id="relay-style-pagination" data-toc="relay-style-pagination">Relay-style pagination</h3><p id="-selosu_74"><a href="https://relay.dev/graphql/connections.htm" id="-selosu_75" data-external="true" rel="noopener noreferrer">Relay-style pagination</a> is a common way of modeling pagination in GraphQL, where fields return <code class="code" id="-selosu_76">Connection</code>s that contain a list of <code class="code" id="-selosu_77">Edges</code>:</p><div class="code-block" data-lang="none">
type Query {
  usersConnection(first: Int = 10, after: String = null, last: Int = null, before: String = null): UserConnection!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge!]!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type UserEdge {
  cursor: String!
  node: User!
}

type User {
  id: ID!
  name: String!
}
</div><div class="code-block" data-lang="none">
query UsersConnection($first: Int, $after: String, $last: Int, $before: String) {
  usersConnection(first: $first, after: $after, last: $last, before: $before) {
    edges {
      cursor
      node {
        name
      }
    }
    pageInfo {
      hasNextPage
      endCursor
    }
  }
}
</div><p id="-selosu_80">If your schema uses this pagination style, the library supports it out of the box: use the <code class="code" id="-selosu_81">connectionFields</code> argument to specify the fields that return a connection:</p><div class="code-block" data-lang="none">
extend type Query @typePolicy(connectionFields: &quot;usersConnection&quot;)
</div><p id="-selosu_83">In Kotlin configure the <code class="code" id="-selosu_84">ApolloStore</code> like this, using the generated <code class="code" id="-selosu_85">Pagination</code> object:</p><div class="code-block" data-lang="kotlin">
val apolloStore = ApolloStore(
  normalizedCacheFactory = cacheFactory,
  metadataGenerator = ConnectionMetadataGenerator(Pagination.connectionTypes),
  recordMerger = ConnectionRecordMerger
)

</div><p id="-selosu_87">Query <code class="code" id="-selosu_88">UsersConnection()</code> to fetch new pages and update the cache, and watch it to observe the full list.</p><p id="-selosu_89">An example of doing this is available <a href="https://github.com/apollographql/apollo-kotlin-normalized-cache-incubating/tree/main/samples/pagination/pagination-support" id="-selosu_90" data-external="true" rel="noopener noreferrer">here</a>.</p></section><section class="chapter"><h3 id="other-types-of-pagination" data-toc="other-types-of-pagination">Other types of pagination</h3><p id="-selosu_91">If your schema uses a different pagination style, you can still use the pagination support, with more configuration needed.</p><section class="chapter"><h4 id="pagination-arguments" data-toc="pagination-arguments">Pagination arguments</h4><p id="-selosu_92">The <code class="code" id="-selosu_93">@fieldPolicy</code> directive has a <code class="code" id="-selosu_94">paginationArgs</code> argument that can be used to specify the arguments that should be omitted from the field key.</p><p id="-selosu_95">Going back to the example above with <code class="code" id="-selosu_96">usersPage</code>:</p><div class="code-block" data-lang="none">
extend type Query
@fieldPolicy(forField: &quot;usersPage&quot; paginationArgs: &quot;page&quot;)
</div><aside class="prompt" data-type="tip" data-title="" id="-selosu_98"><p id="-selosu_99">This can also be done programmatically by configuring the <code class="code" id="-selosu_100">ApolloStore</code> with a <a href="https://apollographql.github.io/apollo-kotlin-normalized-cache-incubating/kdoc/normalized-cache-incubating/com.apollographql.cache.normalized.api/-field-key-generator/index.html?query=interface%20FieldKeyGenerator" id="-selosu_101" data-external="true" rel="noopener noreferrer"><code class="code" id="-selosu_102">FieldKeyGenerator</code></a> implementation.</p></aside><p id="-selosu_103">With that in place, after fetching the first page, the cache will look like this:</p><div class="table-wrapper"><table class="wide" id="-selosu_104"><thead><tr class="ijRowHead" id="-selosu_105"><th id="-selosu_106"><p>Cache Key</p></th><th id="-selosu_107"><p>Record</p></th></tr></thead><tbody><tr id="-selosu_108"><td id="-selosu_109"><p>QUERY_ROOT</p></td><td id="-selosu_110"><p><span class="control" id="-selosu_111">usersPage(groupId: 2)</span>: [ref(user:1), ref(user:2)]</p></td></tr><tr id="-selosu_112"><td id="-selosu_113"><p>user:1</p></td><td id="-selosu_114"><p>id: 1, name: John Smith</p></td></tr><tr id="-selosu_115"><td id="-selosu_116"><p>user:2</p></td><td id="-selosu_117"><p>id: 2, name: Jane Doe</p></td></tr></tbody></table></div><p id="-selosu_118">The field key no longer includes the <code class="code" id="-selosu_119">page</code> argument, which means watching <code class="code" id="-selosu_120">UsersPage(page = 1)</code> or any page will observe the same list.</p><p id="-selosu_121">Here's what happens when fetching the second page:</p><div class="table-wrapper"><table class="wide" id="-selosu_122"><thead><tr class="ijRowHead" id="-selosu_123"><th id="-selosu_124"><p>Cache Key</p></th><th id="-selosu_125"><p>Record</p></th></tr></thead><tbody><tr id="-selosu_126"><td id="-selosu_127"><p>QUERY_ROOT</p></td><td id="-selosu_128"><p>usersPage(groupId: 2): [ref(user:3), ref(user:4)]</p></td></tr><tr id="-selosu_129"><td id="-selosu_130"><p>user:1</p></td><td id="-selosu_131"><p>id: 1, name: John Smith</p></td></tr><tr id="-selosu_132"><td id="-selosu_133"><p>user:2</p></td><td id="-selosu_134"><p>id: 2, name: Jane Doe</p></td></tr><tr id="-selosu_135"><td id="-selosu_136"><p>user:3</p></td><td id="-selosu_137"><p>id: 3, name: Peter Parker</p></td></tr><tr id="-selosu_138"><td id="-selosu_139"><p>user:4</p></td><td id="-selosu_140"><p>id: 4, name: Bruce Wayne</p></td></tr></tbody></table></div><p id="-selosu_141">The field containing the first page was overwritten by the second page.</p><p id="-selosu_142">This is because the field key is now the same for all pages and the default merging strategy is to overwrite existing fields with the new value.</p></section><section class="chapter"><h4 id="record-merging" data-toc="record-merging">Record merging</h4><p id="-selosu_143">To fix this we need to supply the store with a piece of code that can merge the lists in a sensible way. This is done by passing a <a href="https://apollographql.github.io/apollo-kotlin-normalized-cache-incubating/kdoc/normalized-cache-incubating/com.apollographql.cache.normalized.api/-record-merger/index.html?query=interface%20RecordMerger" id="-selosu_144" data-external="true" rel="noopener noreferrer"><code class="code" id="-selosu_145">RecordMerger</code></a> to the <code class="code" id="-selosu_146">ApolloStore</code> constructor:</p><div class="code-block" data-lang="kotlin">
object MyFieldMerger : FieldRecordMerger.FieldMerger {
  override fun mergeFields(existing: FieldRecordMerger.FieldInfo, incoming: FieldRecordMerger.FieldInfo): FieldRecordMerger.FieldInfo {
    val existingList = existing.value as List&lt;*&gt;
    val incomingList = incoming.value as List&lt;*&gt;
    val mergedList = existingList + incomingList
    return FieldRecordMerger.FieldInfo(
        value = mergedList,
        metadata = emptyMap()
    )
  }
}

val apolloStore = ApolloStore(
  normalizedCacheFactory = cacheFactory,
  recordMerger = FieldRecordMerger(MyFieldMerger), // Configure the store with the custom merger
)
</div><p id="-selosu_148">With this, the cache will be as expected after fetching the second page:</p><div class="table-wrapper"><table class="wide" id="-selosu_149"><thead><tr class="ijRowHead" id="-selosu_150"><th id="-selosu_151"><p>Cache Key</p></th><th id="-selosu_152"><p>Record</p></th></tr></thead><tbody><tr id="-selosu_153"><td id="-selosu_154"><p>QUERY_ROOT</p></td><td id="-selosu_155"><p>usersPage(groupId: 2): [ref(user:1), ref(user:2), ref(user:3), ref(user:4)]</p></td></tr><tr id="-selosu_156"><td id="-selosu_157"><p>user:1</p></td><td id="-selosu_158"><p>id: 1, name: John Smith</p></td></tr><tr id="-selosu_159"><td id="-selosu_160"><p>user:2</p></td><td id="-selosu_161"><p>id: 2, name: Jane Doe</p></td></tr><tr id="-selosu_162"><td id="-selosu_163"><p>user:3</p></td><td id="-selosu_164"><p>id: 3, name: Peter Parker</p></td></tr><tr id="-selosu_165"><td id="-selosu_166"><p>user:4</p></td><td id="-selosu_167"><p>id: 4, name: Bruce Wayne</p></td></tr></tbody></table></div><p id="-selosu_168">The <code class="code" id="-selosu_169">RecordMerger</code> shown above is simplistic: it will always append new items to the end of the existing list. In a real app, we need to look at the contents of the incoming page and decide if and where to append / insert the items.</p><p id="-selosu_170">To do that it is usually necessary to have access to the arguments that were used to fetch the existing/incoming lists (e.g. the page number), to decide what to do with the new items. For instance if the existing list is for page 1 and the incoming one is for page 2, we should append.</p><p id="-selosu_171">Fields in records can have arbitrary metadata attached to them, in addition to their value. We'll use this to implement a more capable merging strategy.</p></section><section class="chapter"><h4 id="metadata" data-toc="metadata">Metadata</h4><p id="-selosu_172">Let's go back to the above example where Relay-style pagination is used.</p><p id="-selosu_173">Configure the <code class="code" id="-selosu_174">paginationArgs</code> as seen previously:</p><div class="code-block" data-lang="none">
extend type Query
@fieldPolicy(forField: &quot;usersConnection&quot; paginationArgs: &quot;first,after,last,before&quot;)
</div><p id="-selosu_176">Now let's store in the metadata of each <code class="code" id="-selosu_177">UserConnection</code> field the values of the <code class="code" id="-selosu_178">before</code> and <code class="code" id="-selosu_179">after</code> arguments of the field returning it, as well as the values of the first and last cursor in its list. This will allow us to insert new pages in the correct position later on.</p><p id="-selosu_180">This is done by passing a <a href="https://apollographql.github.io/apollo-kotlin-normalized-cache-incubating/kdoc/normalized-cache-incubating/com.apollographql.cache.normalized.api/-metadata-generator/index.html?query=interface%20MetadataGenerator" id="-selosu_181" data-external="true" rel="noopener noreferrer"><code class="code" id="-selosu_182">MetadataGenerator</code></a> to the <code class="code" id="-selosu_183">ApolloStore</code> constructor:</p><div class="code-block" data-lang="kotlin">
class ConnectionMetadataGenerator : MetadataGenerator {
  @Suppress(&quot;UNCHECKED_CAST&quot;)
  override fun metadataForObject(obj: ApolloJsonElement, context: MetadataGeneratorContext): Map&lt;String, ApolloJsonElement&gt; {
    if (context.field.type.rawType().name == &quot;UserConnection&quot;) {
      obj as Map&lt;String, ApolloJsonElement&gt;
      val edges = obj[&quot;edges&quot;] as List&lt;Map&lt;String, ApolloJsonElement&gt;&gt;
      val startCursor = edges.firstOrNull()?.get(&quot;cursor&quot;) as String?
      val endCursor = edges.lastOrNull()?.get(&quot;cursor&quot;) as String?
      return mapOf(
          &quot;startCursor&quot; to startCursor,
          &quot;endCursor&quot; to endCursor,
          &quot;before&quot; to context.argumentValue(&quot;before&quot;),
          &quot;after&quot; to context.argumentValue(&quot;after&quot;),
      )
    }
    return emptyMap()
  }
}
</div><p id="-selosu_185">However, this cannot work yet.</p><p id="-selosu_186">Normalization will make the <code class="code" id="-selosu_187">usersConnection</code> field value be a <span class="control" id="-selosu_188">reference</span> to the <code class="code" id="-selosu_189">UserConnection</code> record, and not the actual connection. Because of this, we won't be able to access its metadata inside the <code class="code" id="-selosu_190">RecordMerger</code> implementation. Furthermore, the <code class="code" id="-selosu_191">edges</code> field value will be a list of <span class="control" id="-selosu_192">references</span> to the <code class="code" id="-selosu_193">UserEdge</code> records which will contain the item's list index in their cache key (e.g. <code class="code" id="-selosu_194">usersConnection.edges.0</code>, <code class="code" id="-selosu_195">usersConnection.edges.1</code>) which will break the merging logic.</p></section><section class="chapter"><h4 id="embedded-fields" data-toc="embedded-fields">Embedded fields</h4><p id="-selosu_196">To remediate this, we can configure the cache to skip normalization for certain fields. When doing so, the value will be embedded directly into the record instead of being referenced.</p><p id="-selosu_197">This is done with the <code class="code" id="-selosu_198">embeddedFields</code> argument of the <code class="code" id="-selosu_199">@typePolicy</code> directive:</p><div class="code-block" data-lang="none">
# Embed the value of the `usersConnection` field in the record
extend type Query @typePolicy(embeddedFields: &quot;usersConnection&quot;)

# Embed the values of the `edges` field in the record
extend type UserConnection @typePolicy(embeddedFields: &quot;edges&quot;)
</div><aside class="prompt" data-type="tip" data-title="" id="-selosu_201"><p id="-selosu_202">This can also be done programmatically by configuring the <code class="code" id="-selosu_203">ApolloStore</code> with an <a href="https://apollographql.github.io/apollo-kotlin-normalized-cache-incubating/kdoc/normalized-cache-incubating/com.apollographql.cache.normalized.api/-embedded-fields-provider/index.html?query=interface%20EmbeddedFieldsProvider" id="-selosu_204" data-external="true" rel="noopener noreferrer"><code class="code" id="-selosu_205">EmbeddedFieldsProvider</code></a> implementation.</p></aside><p id="-selosu_206">Now that we have the metadata and embedded fields in place, we can implement the <code class="code" id="-selosu_207">RecordMerger</code> (simplified for brevity):</p><div class="code-block" data-lang="kotlin">
object ConnectionFieldMerger : FieldRecordMerger.FieldMerger {
  @Suppress(&quot;UNCHECKED_CAST&quot;)
  override fun mergeFields(existing: FieldRecordMerger.FieldInfo, incoming: FieldRecordMerger.FieldInfo): FieldRecordMerger.FieldInfo {
    // Get existing field metadata
    val existingStartCursor = existing.metadata[&quot;startCursor&quot;]
    val existingEndCursor = existing.metadata[&quot;endCursor&quot;]

    // Get incoming field metadata
    val incomingBeforeArgument = incoming.metadata[&quot;before&quot;]
    val incomingAfterArgument = incoming.metadata[&quot;after&quot;]

    // Get the lists
    val existingList = (existing.value as Map&lt;String, ApolloJsonElement&gt;)[&quot;edges&quot;] as List&lt;*&gt;
    val incomingList = (incoming.value as Map&lt;String, ApolloJsonElement&gt;)[&quot;edges&quot;] as List&lt;*&gt;

    // Merge the lists
    val mergedList: List&lt;*&gt; = if (incomingAfterArgument == existingEndCursor) {
      // We received the next page: its `after` argument matches the last cursor of the existing list
      existingList + incomingList
    } else if (incomingBeforeArgument == existingStartCursor) {
      // We received the previous page: its `before` argument matches the first cursor of the existing list
      incomingList + existingList
    } else {
      // We received a list which is neither the previous nor the next page.
      // Handle this case by resetting the cache with this page
      incomingList
    }

    val mergedFieldValue = existing.value.toMutableMap()
    mergedFieldValue[&quot;edges&quot;] = mergedList
    return FieldRecordMerger.FieldInfo(
        value = mergedFieldValue,
        metadata = mapOf() // Omitted for brevity
    )
  }
}
</div><p id="-selosu_209">A full implementation of <code class="code" id="-selosu_210">ConnectionFieldMerger</code> can be found <a href="https://github.com/apollographql/apollo-kotlin-normalized-cache-incubating/blob/main/normalized-cache-incubating/src/commonMain/kotlin/com/apollographql/cache/normalized/api/RecordMerger.kt#L136" id="-selosu_211" data-external="true" rel="noopener noreferrer">here</a>.</p></section></section></section><div class="last-modified">Last modified: 04 October 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="welcome.html" class="navigation-links__prev">Welcome</a><a href="cache-control.html" class="navigation-links__next">Cache control</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b267/app.js"></script></body></html>