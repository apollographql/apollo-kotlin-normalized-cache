<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-10-13T09:45:45.835744421"><title>Pagination | apollo-kotlin-normalized-cache</title><script type="application/json" id="virtual-toc-data">[{"id":"pagination-with-a-normalized-cache","level":0,"title":"Pagination with a normalized cache","anchor":"#pagination-with-a-normalized-cache"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b575/app.css" rel="stylesheet"><link href="static/custom.css" rel="stylesheet"><link rel="icon" type="image/png" sizes="16x16" href="images/favicon-96x96.png"><link rel="icon" type="image/png" sizes="32x32" href="images/favicon-192x192.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Pagination | apollo-kotlin-normalized-cache"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="apollo-kotlin-normalized-cache Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/pagination-home.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Pagination | apollo-kotlin-normalized-cache"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/pagination-home.html#webpage",
    "url": "writerside-documentation/pagination-home.html",
    "name": "Pagination | apollo-kotlin-normalized-cache",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "apollo-kotlin-normalized-cache Help"
}</script><!-- End Schema.org --></head><body data-id="pagination-home" data-main-title="Pagination" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="" data-edit-url="https://github.com/apollographql/apollo-kotlin-normalized-cache/edit/main/Writerside/topics/pagination/pagination-home.md"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>apollo-kotlin-normalized-cache  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="pagination-home" id="pagination-home.md">Pagination</h1><p id="-iyzopj_3">The normalized cache includes support for pagination, allowing you to merge pages of data into the same record field. This allows your application to watch a query for a list of items, receive updates when new pages are fetched, and update the UI with the full list.</p><ul class="list _bullet" id="-iyzopj_4"><li class="list__item" id="-iyzopj_7"><p>If your schema uses <a href="https://relay.dev/graphql/connections.htm" id="-iyzopj_10" data-external="true" rel="noopener noreferrer">Relay-style</a> pagination, the library <a href="pagination-relay-style.html" id="-iyzopj_11" data-tooltip="Relay-style pagination is a common way of modeling pagination in GraphQL, where fields return Connections that contain a list of Edges:">supports it</a> out of the box.</p></li><li class="list__item" id="-iyzopj_8"><p>For other types of pagination, you can still use the pagination support, with more configuration needed.</p></li><li class="list__item" id="-iyzopj_9"><p>If you need more control, you can also <a href="pagination-manual.html" id="-iyzopj_12" data-tooltip="Using the ApolloStore APIs, you can update the cache manually whenever you fetch a new page of data.">manually handle pagination</a> using the <code class="code" id="-iyzopj_13">ApolloStore</code> APIs.</p></li></ul><p id="-iyzopj_5">Keep reading to learn more about pagination in the context of a normalized cache.</p><section class="chapter"><h2 id="pagination-with-a-normalized-cache" data-toc="pagination-with-a-normalized-cache">Pagination with a normalized cache</h2><p id="-iyzopj_14">When using the normalized cache, objects are stored in records keyed by the object's id:</p><p id="-iyzopj_15">Query:</p><div class="code-block" data-lang="graphql">
query Users {
  allUsers(groupId: 2) {
    id
    name
  }
}
</div><p id="-iyzopj_17">Response:</p><div class="code-block" data-lang="json">
{
  &quot;data&quot;: {
    &quot;allUsers&quot;: [
      {
        &quot;id&quot;: 1,
        &quot;name&quot;: &quot;John Smith&quot;
      },
      {
        &quot;id&quot;: 2,
        &quot;name&quot;: &quot;Jane Doe&quot;
      }
    ]
  }
}
</div><p id="-iyzopj_19">Normalized cache:</p><div class="table-wrapper"><table class="wide" id="-iyzopj_20"><thead><tr class="ijRowHead" id="-iyzopj_36"><th id="-iyzopj_40"><p>Cache Key</p></th><th id="-iyzopj_41"><p>Record</p></th></tr></thead><tbody><tr id="-iyzopj_37"><td id="-iyzopj_42"><p>QUERY_ROOT</p></td><td id="-iyzopj_43"><p>allUsers(groupId: 2): [ref(user:1), ref(user:2)]</p></td></tr><tr id="-iyzopj_38"><td id="-iyzopj_44"><p>user:1</p></td><td id="-iyzopj_45"><p>id: 1, name: John Smith</p></td></tr><tr id="-iyzopj_39"><td id="-iyzopj_46"><p>user:2</p></td><td id="-iyzopj_47"><p>id: 2, name: Jane Doe</p></td></tr></tbody></table></div><p id="-iyzopj_21">The app can watch the <code class="code" id="-iyzopj_48">Users()</code> query and update the UI with the whole list when the data changes.</p><p id="-iyzopj_22">However with pagination things become less obvious:</p><p id="-iyzopj_23">Query:</p><div class="code-block" data-lang="graphql">
query UsersPage($page: Int!) {
  usersPage(groupId: 2, page: $page) {
    id
    name
  }
}
</div><p id="-iyzopj_25">Response:</p><div class="code-block" data-lang="json">
{
  &quot;data&quot;: {
    &quot;usersPage&quot;: [
      {
        &quot;id&quot;: 1,
        &quot;name&quot;: &quot;John Smith&quot;
      },
      {
        &quot;id&quot;: 2,
        &quot;name&quot;: &quot;Jane Doe&quot;
      }
    ]
  }
}
</div><p id="-iyzopj_27">Normalized cache:</p><div class="table-wrapper"><table class="wide" id="-iyzopj_28"><thead><tr class="ijRowHead" id="-iyzopj_49"><th id="-iyzopj_53"><p>Cache Key</p></th><th id="-iyzopj_54"><p>Record</p></th></tr></thead><tbody><tr id="-iyzopj_50"><td id="-iyzopj_55"><p>QUERY_ROOT</p></td><td id="-iyzopj_56"><p>usersPage(groupId: 2, page: 1): [ref(user:1), ref(user:2)]</p></td></tr><tr id="-iyzopj_51"><td id="-iyzopj_57"><p>user:1</p></td><td id="-iyzopj_58"><p>id: 1, name: John Smith</p></td></tr><tr id="-iyzopj_52"><td id="-iyzopj_59"><p>user:2</p></td><td id="-iyzopj_60"><p>id: 2, name: Jane Doe</p></td></tr></tbody></table></div><p id="-iyzopj_29">After fetching page 2, the cache will look like this:</p><div class="table-wrapper"><table class="wide" id="-iyzopj_30"><thead><tr class="ijRowHead" id="-iyzopj_61"><th id="-iyzopj_67"><p>Cache Key</p></th><th id="-iyzopj_68"><p>Record</p></th></tr></thead><tbody><tr id="-iyzopj_62"><td id="-iyzopj_69"><p>QUERY_ROOT</p></td><td id="-iyzopj_70"><p>usersPage(groupId: 2, page: 1): [ref(user:1), ref(user:2)], </p><br><p> usersPage(groupId: 2, page: 2): [ref(user:3), ref(user:4)]</p></td></tr><tr id="-iyzopj_63"><td id="-iyzopj_72"><p>user:1</p></td><td id="-iyzopj_73"><p>id: 1, name: John Smith</p></td></tr><tr id="-iyzopj_64"><td id="-iyzopj_74"><p>user:2</p></td><td id="-iyzopj_75"><p>id: 2, name: Jane Doe</p></td></tr><tr id="-iyzopj_65"><td id="-iyzopj_76"><p>user:3</p></td><td id="-iyzopj_77"><p>id: 3, name: Peter Parker</p></td></tr><tr id="-iyzopj_66"><td id="-iyzopj_78"><p>user:4</p></td><td id="-iyzopj_79"><p>id: 4, name: Bruce Wayne</p></td></tr></tbody></table></div><p id="-iyzopj_31">Which query should the app watch to update the UI?</p><p id="-iyzopj_32">Watching <code class="code" id="-iyzopj_80">UsersPage(page = 1)</code> would only notify changes to the first page.</p><p id="-iyzopj_33">For the whole list to be reactive you'd need to watch the queries for each page, and update the corresponding segment of the list. While technically possible, this is cumbersome to implement.</p><p id="-iyzopj_34">You could skip watching altogether and only update the list when scrolling to its end, but that would mean that changes to individual items would not be reflected in the list UI.</p><p id="-iyzopj_35">What we need is having the whole list in a single field, so we can watch a single query.</p></section><div class="last-modified">Last modified: 19 December 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="options.html" class="navigation-links__prev">Query options</a><a href="pagination-relay-style.html" class="navigation-links__next">Relay-style pagination</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b575/app.js"></script></body></html>